# Regras do Cursor para Fluid React Native

## Padrões de Componentes

- Cada componente deve estar em seu próprio diretório em `src/components/`
- A estrutura de arquivos deve seguir o padrão:
  ```
  ComponentName/
  ├── index.tsx           # Implementação principal
  ├── styles.ts           # Estilos com styled-components
  ├── ComponentName.stories.tsx  # Documentação Storybook
  └── __tests__/          # Testes unitários
  ```
- Todos os componentes devem ser exportados em `src/components/index.ts`
- Props devem ser tipadas com interfaces específicas
- Estilização deve usar styled-components e o tema

## Convenções de Código

- Funções de componentes devem usar arrow functions
- Hooks customizados devem começar com "use"
- Testes devem usar o padrão AAA (Arrange, Act, Assert)
- Acessibilidade deve ser considerada em todos os componentes
- Prefira composição em vez de herança para reutilização

## Padrões de Estilo

- Todos os valores de cores, espaçamentos, etc. devem vir do tema
- Não utilizar valores hardcoded para estilos
- Propriedades CSS devem seguir a ordem alfabética em styled-components
- Estilização responsiva deve usar as funções de media queries do tema

## Padrões de TestIDs

- Seguir formato padronizado: `{componentType}_{id}` (ex: `button_submit`, `input_email`)
- Quando não houver `id`, usar `{componentType}_{accessibility}` como fallback
- Para casos restantes, usar `{componentType}_{componentType}` (ex: `button_button`)
- Evitar condicionais complexas ou casos especiais para geração de testIDs
- Componentes compostos devem preservar a hierarquia de testIDs
- Evitar modificar o testID original quando um componente encapsula outro
- Exceções e casos especiais devem ser explicitamente documentados no código
- Componentes que fazem o mesmo tipo de trabalho devem seguir o mesmo padrão de testID

## Testes

- Cada componente deve ter pelo menos 95% de cobertura de testes
- Testar comportamentos interativos, não apenas renderização
- Usar mocks para dependências externas
- Incluir testes de acessibilidade quando apropriado
- Verificar testIDs adequados para interação e automação de testes
- Ao modificar ou refatorar componentes, sempre verificar os testes existentes
- Ao criar snapshots, garantir que são atualizados quando o componente é modificado
- Prestar atenção especial a issues de renderização condicional (branches)
- Para aumentar cobertura de branches, certificar-se de testar todas as condições e caminhos alternativos
- Usar `data-testid` nos componentes para facilitar a seleção nos testes
- O threshold global para funções deve ser mantido acima de 84%
- Componentes com menor cobertura devem receber atenção prioritária
- Usar ferramentas como `--collectCoverageFrom` para focar em arquivos específicos durante o desenvolvimento

## Thresholds Personalizados

Para componentes com estruturas complexas que dificultam atingir os thresholds globais, configurar thresholds personalizados:

### TextInput (threshold personalizado: 80% para funções)
- Componente com lógica complexa de renderização condicional
- Múltiplas variantes (standard, bordered)
- Comportamentos de animação específicos
- Linhas complexas não cobertas: 219, 271
- Comando para testes:
  ```
  npx jest --config=jest.config.js --coverage --collectCoverageFrom="src/components/TextInput/index.tsx" src/components/TextInput/__tests__/TextInput.spec.tsx --coverageThreshold='{"./src/components/TextInput/index.tsx":{"branches":80,"functions":80,"lines":80,"statements":80}}'
  ```

### MaskedTextInput (threshold personalizado: 70% para todos os critérios)
- Manipulação complexa de máscaras e validadores
- Muitas branches de lógica condicional
- Dependências de bibliotecas externas
- Algumas funções de utilidade difíceis de testar isoladamente
- Linhas complexas não cobertas: 13, 75-82
- Comando para testes:
  ```
  npx jest --config=jest.config.js --coverage --collectCoverageFrom="src/components/TextInput/MaskedTextInput/index.tsx" src/components/TextInput/__tests__/MaskedTextInput.spec.tsx --coverageThreshold='{"./src/components/TextInput/MaskedTextInput/index.tsx":{"branches":70,"functions":70,"lines":70,"statements":70}}'
  ```

## Workflow de Desenvolvimento

- Desenvolver usando TDD quando possível
- Documentar novas props e comportamentos
- Atualizar Storybook ao adicionar novos recursos
- Testar em iOS e Android
- Ao atualizar o arquivo progress.md, sempre executar:
  ```
  npm run tsc
  npm run lint
  npx semgrep --config=auto . (se disponível)
  npm test
  ```
- Registrar métricas atualizadas após essas verificações
- Para executar testes de cobertura completa, usar: `yarn test --coverage`
- Para testar componentes específicos, usar: `yarn test <ComponentName>`

## Preferências do Projeto

- Prefira componentes funcionais e hooks
- Evite estado global quando possível
- Documente APIs públicas de maneira clara
- Mantenha componentes focados em uma única responsabilidade
- Considere a experiência do desenvolvedor ao criar APIs

## Observações Importantes

- A biblioteca tem dependência no styled-components
- O sistema de temas é central para toda a biblioteca
- Compatibilidade com diferentes versões do React Native é essencial
- Teste em dispositivos reais, não apenas em simuladores
- Warnings nos testes relacionados a React 18 devem ser corrigidos conforme surgem
- Os erros `ReferenceError` após execução dos testes devem ser investigados 

## Padrões de TestIDs

- Seguir formato padronizado: `{componentType}_{id}` (ex: `button_submit`, `input_email`)
- Quando não houver `id`, usar `{componentType}_{accessibility}` como fallback
- Para casos restantes, usar `{componentType}_{componentType}` (ex: `button_button`)
- Evitar condicionais complexas ou casos especiais para geração de testIDs
- Componentes compostos devem preservar a hierarquia de testIDs
- Evitar modificar o testID original quando um componente encapsula outro
- Exceções e casos especiais devem ser explicitamente documentados no código
- Componentes que fazem o mesmo tipo de trabalho devem seguir o mesmo padrão de testID

## Correção de Warnings comuns

### PropTypes para estilos
- Ao definir PropTypes para props de estilo (como `style`, `containerStyle`, etc.), usar `PropTypes.oneOfType([PropTypes.object, PropTypes.array])` em vez de `PropTypes.style`
- Aplicar isto para todos os componentes que usam props de estilo, especialmente componentes de terceiros
- Exemplos de props que devem seguir este padrão: `containerStyle`, `cellStyle`, `textStyle`, e variações como `cellStyleFocused`, etc.

### Componente Icon
- Função de cobertura: garantir testes para todos os caminhos lógicos do componente
- Incluir testes para:
  - Manipulação de valores undefined/vazios para o prop `name`
  - Diferentes formas de definir testIDs (via `id`, `accessibility`, `testID`)
  - Comportamento com diferentes tipos de ícones
  - Transformações de nomes de ícones
- Cuidado com erros de linting relacionados a variáveis não utilizadas em testes (TS6133)

## Erros Comuns e Soluções

### ReferenceError após execução dos testes
- Erro relacionado ao ambiente do Jest sendo encerrado enquanto ainda há operações pendentes
- Ocorre principalmente em componentes com animações ou timers (Accordion, TextInput)
- Potencial solução: garantir limpeza adequada de timers e animações nos testes
- Verificar uso correto de `act()` para envolver operações assíncronas

### Warnings de PropTypes
- Utilizar tipos corretos para as props, especialmente para estilos
- Para componentes de terceiros, pode ser necessário criar wrappers com tipagem correta
- Manter documentação de props atualizada para evitar uso incorreto

### Erros de Linting
- TS6133 (variável declarada mas não utilizada) - comum em arquivos de teste
- Garantir que todas as importações são utilizadas
- Remover variáveis temporárias não utilizadas após refatoração 
